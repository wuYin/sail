## 动态规划

### Fib 问题

在递归求解 Fib 数列时会存在大量的重复计算，如下图标出的求 f(5) 时会重复递归计算 f(3)：

![](https://images.yinzige.com/2019-01-02-020021.png)

到此自然会想到用哈希表来存储中间计算的结果，第一次求出 f(3) 后直接存起来，第二次直接取用即可：

```go
func fib(n int) int {
	m := make([]int, n+1)
	m[0], m[1] = 1, 1
	for i := 2; i <= n; i++ {
		m[i] = m[i-1] + m[i-2]
	}
	return m[n]
}
```

如此存储中间计算结果来优化简单递归，便是简单的 DP



### DP 的三个性质

- 最优子结构
- 边界条件
- 状态转移方程

从 [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) 的 DP 解法讲起。假设步梯有 N 个台阶，每次可跨 1 或 2 级，问到达终点有多少种走法？

![](https://images.yinzige.com/2019-01-02-022310.png)

不妨设 N=10，试想到达终点第 10 级，上一步只会存在两种 case

- 从第 9 级跨 1 级
- 从第 8 级跨 2 级

则有 `f(10) = f(9)+f(8)`，这便是求解目标值的 **最优子结构**。

同理 `f(9)=f(8)+f(7);  f(8)=f(7)+f(6); …`，这便是爬楼梯问题的**状态转移方程**。

化解需要有个终点，就是到第 1 级或第 2 级得出**边界条件**：

```
f(1) = 1 // 1
f(2) = 2 // 1+1 // 2
```

如上的三个性质是在将复杂的大问题缩减为小的、有终点的子问题。两个方向的实现如下：



#### 自顶向下的记忆化搜索

按分析可逐层向下分析，递归计算后存储中间计算结果：

```go
// 借助数组保存中间结果，避免重复计算
// 时间 O(N)，空间 O(N)
func climbStairs2(n int) int {
	steps := make([]int, n+1)
	steps[1], steps[2] = 1, 2 // 边界

	for i := 3; i <= n; i++ {
		steps[i] = steps[i-2] + steps[i-1] // 状态转移
	}

	return steps[n] // 最优子结构
}
```



#### 自底向上的状态迭代

存储中间结果耗费 O(N) 空间，换个角度从下到上迭代计算，将结果累计到某个变量中即省去这笔空间：

```go
// 向后累计步数
// 时间 O(N)，空间 O(1)
func climbStairs2(n int) int {
	if n == 1 {
		return 1
	}

	i, j := 1, 2
	for n > 2 {
		i, j = j, i+j // bottom -> up
		n--
	}
	return j
}
```



### 简要总结

DP 一般适合解决三类问题：

- 方案个数统计
- 求最大最小值
- 判断是否可行，是否存在等

DP 关键：从问题中找出最优子结构，分析得出状态转移方程，转移到边界条件。

DP 优点：擅长将 O(2^N) 排列组合指数级解复杂度降低为 O(N) 或 O(N^2) 

DP 缺点：若需借助额外空间，在输入很大时空间代价可能很大。
